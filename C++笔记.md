<center><font size=30> C++笔记 <font ><center>

# 第一章 概述



# 第二章基本类型与变量

## 关键字和标识符

# 第三章 运算符与表达式

## 1.sizeof()运算符

# 第四章 语句结构

## 1. for循环中++i 和 i++ 的区别

for循环的语法定义 ++i 和 i++的结果是一样的，都要等代码块执行完毕才能执行语句3，

但是性能是不同的。在大量数据的时候**++i**的性能要比i++的性能好原因：

i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。

而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能



# 第五章 函数和编译预处理

## 1.编译预处理

### 头文件包含

- 万能头文件 `#incude<bits/stdc++.h>`
- 



# 第七章 数组

## 1.函数形参中的数组究竟是什么?

```c++
void fun(int a[]);
int main(){
int a[]={1,2,3,4,5,6,7,8};
fun(a);
cout<<"main sizeof(a)="<<sizeof(a)<<endl;
}
void fun(int a[]){
cout<<"fun sizeof(a)="<<sizeof(a)<<endl;
}
```

输出结果为

```
fun sizeof(a)=8 //32位系统为4,表示地址字节数
main sizeof(a)=32 //表示数组字节数
```

由此可见其实函数参数表中的数组实际上是指针;



## 2.数组变量是特殊的指针

1.数组变量其实就是常指针;









# 第八章 指针


## 1. 何时在函数形参中使用指针?

1.函数返回多个值,某些值就只能通过指针返回,

此时传入的参数实际上是需要保存带回的结果的变量.

2.函数返回运算的状态,而指针返回运算的结果.

## 2.指针变量使用的误区:

1.定义了了指针变量但未指向变量

## 3.const与指针

1.指针是const:指针不能被修改

2.所指是const:不能通过指针修改值

```c++
int i;
const int* p1=&i;
int const *p2=&i;
int *const p3=&i;
//通过判断const和*的位置关系来判断是哪一种情况
```

3.总是可以把一个非const的值转换成const的

```c++
void f(const int *X);  //表示该函数不会来改变X所指的值
int a=15;
f(a); // OK
const int b=a;
f(&b); // OK
//当要传递的参数的类型比地址大的时候,这是常用的手段:技能用比较少的字节数传递值给参数,又能避免函数对外面的 变量的修改; 

```

4.const int a[]={1,2,3,4,5};表示数组中每个值均为常数,不能再改变,也就是说只能在定义时初始化

## 4.指针的加减

`*p++  //++的运算优先级最高`

## 5.指针数组与指向数组的指针

为了更好的理解[指针](http://c.biancheng.net/c/80/)和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：

`int (*p)[4] = a;`

括号中的`*`表明 p 是一个指针，它指向一个数组，数组的类型为`int [4]`，这正是 a 所包含的每个一维数组的类型。

> `[ ]`的优先级高于`*`，`( )`是必须要加的，如果赤裸裸地写作`int *p[4]`，那么应该理解为`int *(p[4])`，p 就成了一个指针数组，而不是二维数组指针，这在《[C语言指针数组](http://c.biancheng.net/view/2020.html)》中已经讲到。

对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是`int [4]`，那么`p+1`就前进 4×4 = 16 个字节，`p-1`就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，`p+1`会使得指针指向二维数组的下一行，`p-1`会使得指针指向数组的上一行。

# 第十四章 输入输出流

## 输入输出格式总结

在C语言中，有三个函数可以用来在显示器上输出数据，它们分别是：

- puts()：只能输出字符串，并且输出结束后会自动换行，在《[第一个C语言程序](http://c.biancheng.net/view/1734.html)》中已经进行了介绍。
- putchar()：只能输出单个字符，在《[在C语言中使用英文字符](http://c.biancheng.net/view/1766.html)》中已经进行了介绍。
- printf()：可以输出各种类型的数据，在前面的很多章节中都进行了介绍。


printf() 是最灵活、最复杂、最常用的输出函数，完全可以替代 puts() 和 putchar()，大家一定要掌握。前面的章节中我们已经介绍了 printf() 的基本用法，本节将重点介绍 printf() 的高级用法。

> 对于初学者，这一节的内容可能有些繁杂，如果你希望加快学习进度，尽早写出有趣的代码，也可以跳过这节，后面遇到不懂的 printf() 用法再来回顾。

首先汇总一下前面学到的格式控制符：

| 格式控制符                      | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| %c                              | 输出一个单一的字符                                           |
| %hd、%d、%ld                    | 以十进制、有符号的形式输出 short、int、long 类型的整数       |
| %hu、%u、%lu                    | 以十进制、无符号的形式输出 short、int、long 类型的整数       |
| %ho、%o、%lo                    | 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %#ho、%#o、%#lo                 | 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %hx、%x、%lx %hX、%X、%lX       | 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 |
| %#hx、%#x、%#lx %#hX、%#X、%#lX | 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 |
| %f、%lf                         | 以十进制的形式输出 float、double 类型的小数                  |
| %e、%le %E、%lE                 | 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 |
| %g、%lg %G、%lG                 | 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 |
| %s                              | 输出一个字符串                                               |

### printf() 的高级用法

通过前面的学习，相信你已经熟悉了 printf() 的基本用法，但是这还不足以把它发挥到极致，printf() 可以有更加炫酷、更加个性、更加整齐的输出形式。

假如现在老师要我们输出一个 4×4 的整数矩阵，为了增强阅读性，数字要对齐，怎么办呢？我们显然可以这样做：

```c++
#include <stdio.h>
int main(){    
int a1=20, a2=345, a3=700, a4=22;  
int b1=56720, b2=9999, b3=20098, b4=2;   
int c1=233, c2=205, c3=1, c4=6666; 
int d1=34, d2=0, d3=23, d4=23006783; 
printf("%d    %d    %d    %d\n", a1, a2, a3, a4);   
printf("%d    %d    %d    %d\n", b1, b2, b3, b4);  
printf("%d    %d    %d    %d\n", c1, c2, c3, c4);   
printf("%d    %d    %d    %d\n", d1, d2, d3, d4);   
return 0;
}
```

运行结果：

```c++
20        345       700       22
56720     9999      20098     2
233       205       1         6666
34        0         23        23006783
```

> 矩阵一般在大学的《高等数学》中会讲到，m×n 的数字矩阵可以理解为把 m×n 个数字摆放成 m 行 n 列的样子。

看，这是多么地自虐，要敲那么多空格，还要严格控制空格数，否则输出就会错位。更加恶心的是，如果数字的位数变了，空格的数目也要跟着变。例如，当 a1 的值是 20 时，它后面要敲八个空格；当 a1 的值是 1000 时，它后面就要敲六个空格。每次修改整数的值，都要考虑修改空格的数目，逼死强迫症。

类似的需求随处可见，整齐的格式会更加美观，让人觉得生动有趣。其实，我们大可不必像上面一样，printf() 可以更好的控制输出格式。更改上面的代码：

```c++
#include <stdio.h>
int main(){    
int a1=20, a2=345, a3=700, a4=22;   
int b1=56720, b2=9999, b3=20098, b4=2;  
int c1=233, c2=205, c3=1, c4=6666;  
int d1=34, d2=0, d3=23, d4=23006783;  
printf("%-9d %-9d %-9d %-9d\n", a1, a2, a3, a4);
printf("%-9d %-9d %-9d %-9d\n", b1, b2, b3, b4); 
printf("%-9d %-9d %-9d %-9d\n", c1, c2, c3, c4);
printf("%-9d %-9d %-9d %-9d\n", d1, d2, d3, d4);
return 0;
}
```

输出结果：

```
20        345       700       22
56720     9999      20098     2
233       205       1         6666
34        0         23        23006783
```

这样写起来更加方便，即使改变某个数字，也无需修改 printf() 语句，增加或者减少空格数目。

`%-9d`中，`d`表示以十进制输出，`9`表示最少占9个字符的宽度，宽度不足以空格补齐，`-`表示左对齐。综合起来，`%-9d`表示以十进制输出，左对齐，宽度最小为9个字符。大家可以亲自试试`%9d`的输出效果。

### printf() 格式控制符的完整形式如下：

```c++
%[flag][width][.precision]type //注意".precision"里的'.'不要忘记!
```

> [ ] 表示此处的内容可有可无，是可以省略的。

\1) type 表示输出类型，比如 %d、%f、%c、%lf，type 就分别对应 d、f、c、lf；再如，`%-9d`中 type 对应 d。

type 这一项必须有，这意味着输出时必须要知道是什么类型。

2) width 表示最小输出宽度，也就是至少占用几个字符的位置；例如，`%-9d`中 width 对应 9，表示输出结果最少占用 9 个字符的宽度。

当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；当输出结果的宽度超过 width 时，width 不再起作用，按照数据本身的宽度来输出。

下面的代码演示了 width 的用法：

```c++
#include <stdio.h>
int main(){   
int n = 234;   
float f = 9.8;   
char c = '@';   
char *str = "http://c.biancheng.net";
printf("%10d%12f%4c%8s", n, f, c, str);  
return 0;
}
```

运行结果：

```
       234    9.800000   @http://c.biancheng.net
```

对输出结果的说明：

- n 的指定输出宽度为 10，234 的宽度为 3，所以前边要补上 7 个空格。
- f 的指定输出宽度为 12，9.800000 的宽度为 8，所以前边要补上 4 个空格。
- str 的指定输出宽度为 8，"http://c.biancheng.net" 的宽度为 22，超过了 8，所以指定输出宽度不再起作用，而是按照 str 的实际宽度输出。


\3) .precision 表示输出精度，也就是小数的位数。

- 当小数部分的位数大于 precision 时，会按照四舍五入的原则丢掉多余的数字；
- 当小数部分的位数小于 precision 时，会在后面补 0。


==另外，.precision 也可以用于整数和字符串，但是功能却是相反的：==

- 用于整数时，.precision 表示最小输出宽度。与 width 不同的是，整数的宽度不足时会在左边补 0，而不是补空格。
- 用于字符串时，.precision 表示最大输出宽度，或者说截取字符串。当字符串的长度大于 precision 时，会截掉多余的字符；当字符串的长度小于 precision 时，.precision 就不再起作用。


请看下面的例子：

```c++
#include <stdio.h>
int main(){  
int n = 123456;  
double f = 882.923672;   
char *str = "abcdefghi";  
printf("n: %.9d  %.4d\n", n, n);   
printf("f: %.2lf  %.4lf  %.10lf\n", f, f, f);  
printf("str: %.5s  %.15s\n", str, str);  
return 0;
}
```

运行结果：

```
n: 000123456  123456
f: 882.92  882.9237  882.9236720000
str: abcde  abcdefghi
```

对输出结果的说明：

- 对于 n，.precision 表示最小输出宽度。n 本身的宽度为 6，当 precision 为 9 时，大于 6，要在 n 的前面补 3 个 0；当 precision 为 4 时，小于 6，不再起作用。
- 对于 f，.precision 表示输出精度。f 的小数部分有 6 位数字，当 precision 为 2 或者 4 时，都小于 6，要按照四舍五入的原则截断小数；当 precision 为 10 时，大于 6，要在小数的后面补四个 0。
- 对于 str，.precision 表示最大输出宽度。str 本身的宽度为 9，当 precision 为 5 时，小于 9，要截取 str 的前 5 个字符；当 precision 为 15 时，大于 9，不再起作用。


\4) flag 是标志字符。例如，`%#x`中 flag 对应 #，`%-9d`中 flags 对应`-`。下表列出了 printf() 可以用的 flag：

| 标志字符 | 含  义                                                       |
| -------- | ------------------------------------------------------------ |
| -        | `-`表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。 |
| +        | 用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。 |
| 空格     | 用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。     |
| #        | 对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。 |


请看下面的例子：

```c
#include <stdio.h>
int main(){   
int m = 192, n = -943;  
float f = 84.342;   
printf("m=%10d, m=%-10d\n", m, m);  //演示 - 的用法    printf("m=%+d, n=%+d\n", m, n);  //演示 + 的用法    printf("m=% d, n=% d\n", m, n);  //演示空格的用法    printf("f=%.0f, f=%#.0f\n", f, f);  //演示#的用法    return 0;
}
```

运行结果：

```
m=       192, m=192      
m=+192, n=-943
m= 192, n=-943
f=84, f=84.
```

对输出结果的说明：

- 当以`%10d`输出 m 时，是右对齐，所以在 192 前面补七个空格；当以`%-10d`输出 m 时，是左对齐，所以在 192 后面补七个空格。
- m 是正数，以`%+d`输出时要带上正号；n 是负数，以`%+d`输出时要带上负号。
- m 是正数，以`% d`输出时要在前面加空格；n 是负数，以`% d`输出时要在前面加负号。
- `%.0f`表示保留 0 位小数，也就是只输出整数部分，不输出小数部分。默认情况下，这种输出形式是不带小数点的，但是如果有了`#`标志，那么就要在整数的后面“硬加上”一个小数点，以和纯整数区分开。

### printf() 不能立即输出的问题

printf() 有一个尴尬的问题，就是有时候不能立即输出，请看下面的代码：

```c++
#include<stdio.h>
#include<unistd.h>
int main(){   
printf("C语言中文网");   
sleep(5);  //程序暂停5秒钟    printf("http://c.biancheng.net\n");  
return 0;
}
```

这段代码使用了两个 printf() 语句，它们之间有一个 sleep() 函数，该函数的作用是让程序暂停 5 秒，然后再继续执行。sleep() 是 Linux 和 Mac OS 下特有的函数，不能用于 Windows。当然，Windows 下也有功能相同的暂停函数，叫做 Sleep()，稍后我们会讲解。

在 Linux 或者 Mac OS 下运行该程序，会发现第一个 printf() 并没有立即输出，而是等待 5 秒以后，和第二个 printf() 一起输出了，请看下面的动图演示：
![img](http://c.biancheng.net/uploads/allimg/181228/103F514A-0.gif)
我们不妨修改一下代码，在第一个 printf() 的最后添加一个换行符，如下所示：

printf("C语言中文网\n");

再次编译并运行程序，发现第一个 printf() 首先输出（程序运行后立即输出），等待 5 秒以后，第二个 printf() 才输出，请看下面的动图演示：
![img](http://c.biancheng.net/uploads/allimg/181228/103F5K25-1.gif)
为什么一个换行符`\n`就能让程序的表现有天壤之别呢？按照通常的逻辑，程序运行后第一个 printf() 应该立即输出，而不是等待 5 秒以后再和第二个 printf() 一起输出，也就是说，第二种情形才符合我们的惯性思维。然而，第一种情形该如何理解呢？

其实，这一切都是输出缓冲区（缓存）在作怪！

从本质上讲，printf() 执行结束以后数据并没有直接输出到显示器上，而是放入了缓冲区，直到遇见换行符`\n`才将缓冲区中的数据输出到显示器上。更加深入的内容，我们将在本章的《[进入缓冲区（缓存）的世界，破解一切与输入输出有关的疑难杂症](http://c.biancheng.net/view/vip_1797.html)》中详细讲解。

以上测试的是 Linux 和 Mac OS，我们不妨再测试一下 Windows，请看下面的代码：

```c++
#include<stdio.h>
#include<Windows.h>
int main(){   
printf("C语言中文网"); 
Sleep(5000);  //程序暂停5秒钟 
printf("http://c.biancheng.net\n");  
return 0;
}
```

在 Windows 下，想让程序暂停可以使用 Windows.h 头文件中的 Sleep() 函数（`S`要大写），它和 Linux 下的 sleep() 功能相同。不过，sleep() 要求的时间单位是秒，而 Sleep() 要求的时间单位是毫秒，1 秒等于 1000 毫秒。这段代码中，我们要求程序暂停 5000 毫秒，也即 5 秒。

编译并运行程序，会发现第一个 printf() 首先输出（程序运行后立即输出），等待 5 秒以后，第二个 printf() 才输出，请看下面的动画演示：
![img](http://c.biancheng.net/uploads/allimg/181228/103F56317-2.gif)

在第一个 printf() 的最后添加一个换行符，情况也是一样的，第一个 printf() 从来不会和第二个 printf() 一起输出。

你看，Windows 和 Linux、Mac OS 的情况又不一样。这是因为，Windows 和 Linux、Mac OS 的缓存机制不同。更加深入的内容，我们将在本章的《[进入缓冲区（缓存）的世界，破解一切与输入输出有关的疑难杂症](http://c.biancheng.net/view/vip_1797.html)》中详细讲解。

要想破解 printf() 输出的问题，必须要了解缓存，它能使你对输入输出的认识上升到一个更高的层次，以后不管遇到什么疑难杂症，都能迎刃而解。可以说，输入输出的“命门”就在于缓存。

# 问题

## 1.malloc和new 的区别:

malloc 函数原型为

void *malloc(int size)

## 2.typedef和define的区别





































​     
